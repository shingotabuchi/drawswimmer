#pragma kernel Init
#pragma kernel Collisions
#pragma kernel Streaming
#pragma kernel Boundaries
#pragma kernel PlotSpeed
#pragma kernel ImmersedBoundary
#pragma kernel ImmersedBoundaryColloids
#pragma kernel InitRoundParticles
#pragma kernel InitRoundParticlesAtCenter
#pragma kernel PlotParticle
#pragma kernel PlotParticleOnlyEdge
#pragma kernel Draw
#pragma kernel PlotDrawParticles
#pragma kernel ClearParticleTexture
#pragma kernel InitDrawParticles
#pragma kernel DrawParticleBoundary
RWTexture2D<float4> renderTexture;
RWTexture2D<float4> particleRenderTexture;
uint DIM_X;
uint DIM_Y;
uint ParticleDIM_X;
uint ParticleDIM_Y;
int particleCount;
int particlePerimeterCount;
int maxDrawParticlePerimeterCount;
int maxXNodes;
int wavecount;
int shuuki;
float wavescale;
bool drawParticlesInitialized;
RWStructuredBuffer<float> uv,f;
RWStructuredBuffer<float2> velocityBuffer;

bool isTouched;
float2 touchTextureCoord;
float particlePointLatticeSpacing;

struct RoundParticleSmallData
{
	float density;
    float omega;//角速度
    float theta;//角
    float prevOmega1;//前フレームの角速度
    float prevOmega2;//前々フレームの角速度
    float torque;
    int perimeterPointCount;
    float volume;
    float mass;
    float momentOfInertia;
    float radius;
    int bottomPointIndex;

    float2 pos;
    float2 vel;
    float2 prevVel1;
    float2 prevVel2;
    float2 forceFromCollisions;
    float2 forceFromFluid;

    bool notActive;
};

struct DrawParticleSmallData
{
	float density;
    float omega;//角速度
    float theta;//角
    float prevOmega1;//前フレームの角速度
    float prevOmega2;//前々フレームの角速度
    float torque;
    int perimeterPointCount;
    float mass;
    float momentOfInertia;
    int time;
    int bottomPointIndex;

    float2 pos;
    float2 vel;
    float2 prevVel1;
    float2 prevVel2;
    float2 forceFromCollisions;
    float2 forceFromFluid;
};

RWStructuredBuffer<RoundParticleSmallData> roundParticleSmallDataBuffer;
RWStructuredBuffer<DrawParticleSmallData> drawParticleSmallDataBuffer;

RWStructuredBuffer<float2> roundParticleRoundParticlePerimeterPosBuffer;
RWStructuredBuffer<float2> roundParticleRoundParticlePerimeterVelBuffer;
RWStructuredBuffer<float2> roundParticleRoundParticlePerimeterFluidVelBuffer;
RWStructuredBuffer<float2> roundParticleRoundParticleForceOnPerimeterBuffer;

RWStructuredBuffer<float2> drawParticlePerimeterRelPosBuffer;
RWStructuredBuffer<float2> drawParticlePerimeterPosBuffer;
RWStructuredBuffer<float2> drawParticlePerimeterVelBuffer;
RWStructuredBuffer<float2> drawParticlePerimeterFluidVelBuffer;
RWStructuredBuffer<float2> drawParticleForceOnPerimeterBuffer;

RWStructuredBuffer<float> force;
RWStructuredBuffer<int> nodeX;

RWStructuredBuffer<float2> particleInitPos;


float tauf,u0;
float minSpeed,maxSpeed;
float particleDensity;
float particleRadius;
float colloidRadius;
float colloidDensity;
float epsw, zeta;
float touchForceRadius;
float touchForce;
float squirmerBeta,squirmerSpeedConstant;
float maxRadius;
int drawParticleMode;
float4 ColorMap(float val, float maxVal)
{
    if(val > maxVal) val = maxVal;
    float4 colorsOfMap[7] = 
    {
        float4(0,0,0,1),
        float4(0,0,1,1),
        float4(0,1,1,1),
        float4(0,1,0,1),
        float4(1,1,0,1),
        float4(1,0,0,1),
        float4(1,1,1,1),
    };

    float valPerc = val / maxVal;// value%
    float colorPerc = 1.0 / (7.0-1.0);// % of each block of color. the last is the "100% Color"
    int blockIdx = (int)(valPerc / colorPerc);// Idx of 
    float valPercResidual = valPerc - (blockIdx*colorPerc);//remove the part represented of block 
    float percOfColor = valPercResidual / colorPerc;// % of color of this block that will be filled
    float4 cTarget = colorsOfMap[blockIdx];
    float deltaR = 0;
    float deltaG = 0;
    float deltaB = 0;

    if(blockIdx != 6)
    {
        float4 cNext = colorsOfMap[blockIdx + 1];
        deltaR =cNext.x - cTarget.x;
        deltaG =cNext.y - cTarget.y;
        deltaB =cNext.z - cTarget.z;
    }

    float R = cTarget.r + (deltaR * percOfColor);
    float G = cTarget.g + (deltaG * percOfColor);
    float B = cTarget.b + (deltaB * percOfColor);

    return float4(R,G,B,1.0);
}

[numthreads(1, 1, 1)]
void Draw(uint3 id : SV_DispatchThreadID)
{
    if(isTouched)
    {
        float2 boundaryPos = float2(
            (touchTextureCoord.x*(DIM_X-1))/1080.0,
            (touchTextureCoord.y*(DIM_Y-1))/1080.0
        );
        uint2 plotpos = uint2(
            (uint)((touchTextureCoord.x*(ParticleDIM_X-1))/1080.0),
            (uint)((touchTextureCoord.y*(ParticleDIM_Y-1))/1080.0)
        );
        // particleRenderTexture[touchpos] = float4(1,1,1,1);
        particleRenderTexture[plotpos] = float4(0,0,0,1);

        drawParticlePerimeterPosBuffer[0*maxDrawParticlePerimeterCount + drawParticleSmallDataBuffer[0].perimeterPointCount] = boundaryPos;
        drawParticleSmallDataBuffer[0].perimeterPointCount++;
        // thisan
    }
    else
    {
        drawParticleSmallDataBuffer[0].perimeterPointCount = 0;
    }
}

[numthreads(8, 8, 1)]
void ClearParticleTexture(uint3 id : SV_DispatchThreadID)
{
    particleRenderTexture[id.xy] = float4(0,0,0,0);
}
float SqrMagnitude(float2 vec)
{
    return vec.x*vec.x + vec.y*vec.y;
}
float2 RotateVec(float2 vec,float theta)
{
    return float2(
        vec.x * cos(theta) - vec.y * sin(theta),
        vec.x * sin(theta) + vec.y * cos(theta)
    );
}
[numthreads(64, 1, 1)]
void InitDrawParticles(uint3 id : SV_DispatchThreadID)
{
    float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
    int x,y;
    int nodes;
    int i, j, swap;
    int massPointCount = 0;
    drawParticleSmallDataBuffer[id.x].mass = 0;
    drawParticleSmallDataBuffer[id.x].pos = float2(0,0);
    drawParticleSmallDataBuffer[id.x].vel = float2(0,0);
    drawParticleSmallDataBuffer[id.x].prevVel1 = float2(0,0);
    drawParticleSmallDataBuffer[id.x].prevVel2 = float2(0,0);
    drawParticleSmallDataBuffer[id.x].forceFromCollisions = float2(0,0);
    drawParticleSmallDataBuffer[id.x].forceFromFluid = float2(0,0);
    drawParticleSmallDataBuffer[id.x].theta = 0;
    drawParticleSmallDataBuffer[id.x].omega = 0;
    drawParticleSmallDataBuffer[id.x].time = 0;
    drawParticleSmallDataBuffer[id.x].prevOmega1 = 0;
    drawParticleSmallDataBuffer[id.x].prevOmega2 = 0;
    drawParticleSmallDataBuffer[id.x].torque = 0;
    drawParticleSmallDataBuffer[id.x].momentOfInertia = 0;
    drawParticleSmallDataBuffer[id.x].density = particleDensity;

    int ppc = drawParticleSmallDataBuffer[id.x].perimeterPointCount;

    for(y = 0; y < (int)DIM_Y; y++)
    {
        nodes=0; j=drawParticleSmallDataBuffer[id.x].perimeterPointCount-1;
        for (i=0; i<drawParticleSmallDataBuffer[id.x].perimeterPointCount; i++) 
        {
            float iPolyY = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + i].y;
            float jPolyY = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + j].y;
            float iPolyX = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + i].x;
            float jPolyX = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + j].x;
            if (iPolyY<(float)y && jPolyY>=(float)y
            ||  jPolyY<(float)y && iPolyY>=(float)y)
            {
                nodeX[maxXNodes*y + nodes++]=(int) (iPolyX+(y-iPolyY)/(jPolyY-iPolyY)
                *(jPolyX-iPolyX)); 
                if(nodes >= maxXNodes) break;
            }
            j=i; 
        }
        i=0;
        while (i<nodes-1) 
        {
            if (nodeX[maxXNodes*y + i]>nodeX[maxXNodes*y + i+1]) 
            {
                swap=nodeX[maxXNodes*y + i]; 
                nodeX[maxXNodes*y + i]=nodeX[maxXNodes*y + i+1]; 
                nodeX[maxXNodes*y + i+1]=swap; 
                if (i) i--; 
            }
            else 
            {
                i++; 
            }
        }
        for (i=0; i<nodes; i+=2) 
        {
            if   (nodeX[maxXNodes*y + i  ]>=(int)DIM_X) break;
            if   (nodeX[maxXNodes*y + i+1]> 0 ) 
            {
                if (nodeX[maxXNodes*y + i  ]< 0 ) nodeX[maxXNodes*y + i  ]=0 ;
                if (nodeX[maxXNodes*y + i+1]> (int)DIM_X) nodeX[maxXNodes*y + i+1]=(int)DIM_X;
                for (x=nodeX[maxXNodes*y + i]; x<nodeX[maxXNodes*y + i+1]; x++) 
                {
                    massPointCount++;
                    drawParticleSmallDataBuffer[id.x].pos += float2(x,y);
                }
            }
        }
    }

    drawParticleSmallDataBuffer[id.x].pos /= massPointCount;
    drawParticleSmallDataBuffer[id.x].mass = massPointCount * drawParticleSmallDataBuffer[id.x].density;
    for(y = 0; y < (int)DIM_Y; y++)
    {
        nodes=0; j=drawParticleSmallDataBuffer[id.x].perimeterPointCount-1;
        for (i=0; i<drawParticleSmallDataBuffer[id.x].perimeterPointCount; i++) 
        {
            float iPolyY = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + i].y;
            float jPolyY = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + j].y;
            float iPolyX = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + i].x;
            float jPolyX = drawParticlePerimeterPosBuffer[id.x*maxDrawParticlePerimeterCount + j].x;
            if (iPolyY<(float)y && jPolyY>=(float)y
            ||  jPolyY<(float)y && iPolyY>=(float)y)
            {
                nodeX[maxXNodes*y + nodes++]=(int) (iPolyX+(y-iPolyY)/(jPolyY-iPolyY)
                *(jPolyX-iPolyX)); 
                if(nodes >= maxXNodes) break;
            }
            j=i; 
        }
        i=0;
        while (i<nodes-1) 
        {
            if (nodeX[maxXNodes*y + i]>nodeX[maxXNodes*y + i+1]) 
            {
                swap=nodeX[maxXNodes*y + i]; 
                nodeX[maxXNodes*y + i]=nodeX[maxXNodes*y + i+1]; 
                nodeX[maxXNodes*y + i+1]=swap; 
                if (i) i--; 
            }
            else 
            {
                i++; 
            }
        }
        for (i=0; i<nodes; i+=2) 
        {
            if   (nodeX[maxXNodes*y + i  ]>=(int)DIM_X) break;
            if   (nodeX[maxXNodes*y + i+1]> 0 ) 
            {
                if (nodeX[maxXNodes*y + i  ]< 0 ) nodeX[maxXNodes*y + i  ]=0 ;
                if (nodeX[maxXNodes*y + i+1]> (int)DIM_X) nodeX[maxXNodes*y + i+1]=(int)DIM_X;
                for (x=nodeX[maxXNodes*y + i]; x<nodeX[maxXNodes*y + i+1]; x++) 
                {
                   //デバッグ用
                    renderTexture[uint2(x,y)] = float4(0,0,0,1);
                    float sqrDist = SqrMagnitude(float2(x,y) - drawParticleSmallDataBuffer[id.x].pos);
                    drawParticleSmallDataBuffer[id.x].momentOfInertia += drawParticleSmallDataBuffer[id.x].density * sqrDist;
                }
            }
        }
    }
    for(i = 0; i < ppc; i++) 
    {
        drawParticlePerimeterRelPosBuffer[id.x*ppc + i] = drawParticlePerimeterPosBuffer[id.x*ppc + i] - drawParticleSmallDataBuffer[id.x].pos;
        drawParticlePerimeterPosBuffer[id.x*ppc + i] = RotateVec(drawParticlePerimeterRelPosBuffer[id.x*ppc + i],drawParticleSmallDataBuffer[id.x].theta) + drawParticleSmallDataBuffer[id.x].pos;

        drawParticlePerimeterVelBuffer[id.x*ppc + i].x = drawParticleSmallDataBuffer[id.x].vel.x - drawParticleSmallDataBuffer[id.x].omega*(drawParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y - drawParticleSmallDataBuffer[id.x].pos.y);
        drawParticlePerimeterVelBuffer[id.x*ppc + i].y = drawParticleSmallDataBuffer[id.x].vel.y + drawParticleSmallDataBuffer[id.x].omega*(drawParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x - drawParticleSmallDataBuffer[id.x].pos.x);
        drawParticleForceOnPerimeterBuffer[id.x*ppc + i] = float2(0,0);
        drawParticlePerimeterFluidVelBuffer[id.x*ppc + i] = float2(0,0);
    } 
}


[numthreads(64, 1, 1)]
void PlotDrawParticles(uint3 id : SV_DispatchThreadID)
{
    int y = id.x;
    int nodes;
    int xBorderNodesCount = 0;
    int yBorderNodesCount = 0;
    int xBorderNodes[16];
    int yBorderNodes[16];
    int pixelX;
    int i, j, swap;
     
    nodes=0; j=drawParticleSmallDataBuffer[0].perimeterPointCount-1;
    bool edgeIncluded = false;
    for (i=0; i<drawParticleSmallDataBuffer[0].perimeterPointCount; i++) 
    {
        float iPolyY = (drawParticlePerimeterPosBuffer[0*maxDrawParticlePerimeterCount + i].y*(ParticleDIM_Y-1))/(DIM_Y-1);
        float jPolyY = (drawParticlePerimeterPosBuffer[0*maxDrawParticlePerimeterCount + j].y*(ParticleDIM_Y-1))/(DIM_Y-1);
        float iPolyX = (drawParticlePerimeterPosBuffer[0*maxDrawParticlePerimeterCount + i].x*(ParticleDIM_X-1))/(DIM_X-1);
        float jPolyX = (drawParticlePerimeterPosBuffer[0*maxDrawParticlePerimeterCount + j].x*(ParticleDIM_X-1))/(DIM_X-1);
        if (iPolyY<(float)y && jPolyY>=(float)y
        ||  jPolyY<(float)y && iPolyY>=(float)y)
        {
            int newNodeX = (int) (iPolyX+(y-iPolyY)/(jPolyY-iPolyY)
            *(jPolyX-iPolyX)); 
            nodeX[maxXNodes*y + nodes++]=newNodeX;
            if(newNodeX == 0)edgeIncluded = true;
            // if(newNodeX == 1)edgeIncluded = true;
            // if(newNodeX == (int)ParticleDIM_X)edgeIncluded = true;
            if(newNodeX == (int)ParticleDIM_X-1)edgeIncluded = true;
            if(nodes >= maxXNodes-2) break;
            // nodeX[maxXNodes*y + nodes++]=(int) iPolyX;
        }

        if(iPolyX-jPolyX>(float)ParticleDIM_X/2)
        {
            iPolyX -= ParticleDIM_X;
            xBorderNodes[xBorderNodesCount] = (int)(iPolyY+(0-iPolyX)/(jPolyX-iPolyX)
            *(jPolyY-iPolyY)); 
            xBorderNodesCount++;
        }
        else if(jPolyX-iPolyX>(float)ParticleDIM_X/2)
        {
            jPolyX -= ParticleDIM_X;
            xBorderNodes[xBorderNodesCount] = (int)(jPolyY+(0-jPolyX)/(iPolyX-jPolyX)
            *(iPolyY-jPolyY)); 
            xBorderNodesCount++;
        }
        j=i; 
    }
    i=0;
    while (i<xBorderNodesCount-1) 
    {
        if (xBorderNodes[i]>xBorderNodes[i+1]) 
        {
            swap=xBorderNodes[i]; 
            xBorderNodes[i]=xBorderNodes[i+1]; 
            xBorderNodes[i+1]=swap; 
            if (i) i--; 
        }
        else 
        {
            i++; 
        }
    }
    for (i=0; i<xBorderNodesCount; i+=2) 
    {
        if(y>=xBorderNodes[i] && y<=xBorderNodes[i+1])
        {
            if(!edgeIncluded)
            {
                nodeX[maxXNodes*y + nodes++] = 0;
                nodeX[maxXNodes*y + nodes++] = ParticleDIM_X;
            }
        }
    }

    i=0;
    while (i<nodes-1) 
    {
        if (nodeX[maxXNodes*y + i]>nodeX[maxXNodes*y + i+1]) 
        {
            swap=nodeX[maxXNodes*y + i]; 
            nodeX[maxXNodes*y + i]=nodeX[maxXNodes*y + i+1]; 
            nodeX[maxXNodes*y + i+1]=swap; 
            if (i) i--; 
        }
        else 
        {
            i++; 
        }
    }
    
    // bool isOnBorder = false;
    // for (i=0; i<nodes-1; i++)
    // {
    //     if(nodeX[maxXNodes*y + i+1] - nodeX[maxXNodes*y + i] >= (int)maxRadius)
    //     {
    //         isOnBorder = true;
    //         break;
    //     }
    // }

    // if(isOnBorder)
    // {
    //     for (i=nodes-1; i>=0; i--)
    //     {
    //         nodeX[maxXNodes*y + i+1] = nodeX[maxXNodes*y + i];
    //     }
    //     nodeX[maxXNodes*y + 0] = 0;
    //     nodeX[maxXNodes*y + nodes+1] = (int)ParticleDIM_X-1;
    //     nodes = nodes+2;
    // }

    for (i=0; i<nodes; i+=2) 
    {
        if   (nodeX[maxXNodes*y + i  ]>=(int)ParticleDIM_X) break;
        if   (nodeX[maxXNodes*y + i+1]> 0 ) 
        {
            if (nodeX[maxXNodes*y + i  ]< 0 ) nodeX[maxXNodes*y + i  ]=0 ;
            if (nodeX[maxXNodes*y + i+1]> (int)ParticleDIM_X) nodeX[maxXNodes*y + i+1]=(int)ParticleDIM_X;
            for (pixelX=nodeX[maxXNodes*y + i]; pixelX<nodeX[maxXNodes*y + i+1]; pixelX++) 
            {
                particleRenderTexture[uint2(pixelX,y)] = float4(1,1,1,1);
                // particleRenderTexture[uint2(pixelX,y)] = float4(0,0,0,1);
            }
        }
    }
}

// [numthreads(1, 1, 1)]
// void InitDrawParticles(uint3 id : SV_DispatchThreadID)
// {

// }


[numthreads(8, 8, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    float cx[9] = {0, 1,    0,   -1,    0,     1,    -1,    -1,     1};
    float cy[9] = {0, 0,    1,    0,   -1,     1,     1,    -1,    -1};
    float wf[9] = {4.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/36.0,1.0/36.0,1.0/36.0,1.0/36.0};
    float tmp;
    uv[(id.x + id.y * DIM_X)*2 + 0] = 0.0; 
    uv[(id.x + id.y * DIM_X)*2 + 1] = 0.0; 
    force[0 + (id.x + id.y * DIM_X)*2] = 0.0;
    force[1 + (id.x + id.y * DIM_X)*2] = 0.0;
    // if(id.y == DIM - 1) uv[(id.x + id.y * DIM_X)*2 + 0] = u0;
    int k;
    for(k = 0; k < 9; k++)
    {
        tmp = cx[k]*uv[(id.x + id.y * DIM_X)*2 + 0] + cy[k]*uv[(id.x + id.y * DIM_X)*2 + 1];     
        f[k + (id.x + id.y * DIM_X)*9] = wf[k]*(1.0 +3.0*tmp +9.0/2.0*tmp*tmp);
    }
}
[numthreads(8, 8, 1)]
void Collisions(uint3 id : SV_DispatchThreadID)
{
    float cx[9] = {0, 1,    0,   -1,    0,     1,    -1,    -1,     1};
    float cy[9] = {0, 0,    1,    0,   -1,     1,     1,    -1,    -1};
    float wf[9] = {4.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/36.0,1.0/36.0,1.0/36.0,1.0/36.0};
    // float fx = 0.0; 
    // float fy = 0.0; 
    int k;
    float temperature = 0.0;
    float rho = 0.0;
    uv[(id.x + id.y * DIM_X)*2 + 0] = 0.0; 
    uv[(id.x + id.y * DIM_X)*2 + 1] = 0.0; 
    for(k = 0; k < 9; k++)
    {
        rho += f[k + (id.x + id.y * DIM_X)*9];
    }
    // if(id.y == DIM_Y - 1) rho = f[0+ (id.x + (DIM_Y-1)*DIM_X)*9] + f[1+ (id.x + (DIM_Y-1)*DIM_X)*9] + f[3+ (id.x + (DIM_Y-1)*DIM_X)*9] 
    //     +2.0 * (f[2+ (id.x + (DIM_Y-1)*DIM_X)*9] + f[6+ (id.x + (DIM_Y-1)*DIM_X)*9]  +f[5+ (id.x + (DIM_Y-1)*DIM_X)*9]);
    for(k = 0; k < 9; k++)
    {
        uv[(id.x + id.y * DIM_X)*2 + 0] += f[k + (id.x + id.y * DIM_X)*9]*cx[k]/rho;
        uv[(id.x + id.y * DIM_X)*2 + 1] += f[k + (id.x + id.y * DIM_X)*9]*cy[k]/rho;
    }

    velocityBuffer[id.x + id.y * DIM_X] = float2(uv[(id.x + id.y * DIM_X)*2 + 0],uv[(id.x + id.y * DIM_X)*2 + 1]);

    // if(id.y == DIM - 1) uv[(id.x + id.y * DIM_X)*2 + 0] = u0;

    float u2 = uv[(id.x + id.y * DIM_X)*2 + 0]*uv[(id.x + id.y * DIM_X)*2 + 0] + uv[(id.x + id.y * DIM_X)*2 + 1]*uv[(id.x + id.y * DIM_X)*2 + 1];   
    // float fy = 0;


    if(isTouched)
    {
        float2 touchCoords[] = 
        {
            touchTextureCoord,
            touchTextureCoord + float2( 1.0, 0.0),
            touchTextureCoord + float2(-1.0, 0.0),
            touchTextureCoord + float2( 0.0, 1.0),
            touchTextureCoord + float2( 0.0,-1.0)
        };
        float x = (float)id.x/(float)(DIM_X-1) - 0.5;
        float y = (float)id.y/(float)(DIM_Y-1) - 0.5;

        for(int touchCoordIndex = 0; touchCoordIndex < 5; touchCoordIndex++)
        {
            float2 coordFromTouch = float2(x,y) - touchCoords[touchCoordIndex];
            float distFromTouchSqrd =  coordFromTouch.x * coordFromTouch.x + coordFromTouch.y * coordFromTouch.y;
            if(distFromTouchSqrd < touchForceRadius*touchForceRadius)
            {
                force[0 + (id.x + id.y * DIM_X)*2] += -touchForce * coordFromTouch.y;
                force[1 + (id.x + id.y * DIM_X)*2] += touchForce * coordFromTouch.x;
                break;
            }
        }
    }

    for (k = 0; k < 9; k++)
    {
        float tmp = cx[k]*uv[(id.x + id.y * DIM_X)*2 + 0] + cy[k]*uv[(id.x + id.y * DIM_X)*2 + 1];     
        float f0 = wf[k]*rho*(1.0 +3.0*tmp +9.0/2.0*tmp*tmp -3.0/2.0*u2);
        f[k + (id.x + id.y * DIM_X)*9] = f[k + (id.x + id.y * DIM_X)*9] - (f[k + (id.x + id.y * DIM_X)*9] - f0)/tauf + 3.0*wf[k]*(cx[k]*force[0 + (id.x + id.y * DIM_X)*2] + cy[k]*force[1 + (id.x + id.y * DIM_X)*2]);
        f[DIM_X*DIM_Y*9 + k + (id.x + id.y * DIM_X)*9] = f[k + (id.x + id.y * DIM_X)*9];
    }
    force[0 + (id.x + id.y * DIM_X)*2] = 0.0;
    force[1 + (id.x + id.y * DIM_X)*2] = 0.0;
}
[numthreads(8, 8, 1)]
void Streaming(uint3 id : SV_DispatchThreadID)
{
    float cx[9] = {0, 1,    0,   -1,    0,     1,    -1,    -1,     1};
    float cy[9] = {0, 0,    1,    0,   -1,     1,     1,    -1,    -1};
    int k;
    for(k = 0; k < 9; k++)
    {
        int im = ((int)id.x + (int)cx[k] + (int)DIM_X)%DIM_X; 
        int jm = ((int)id.y + (int)cy[k] + (int)DIM_Y)%DIM_Y;
        f[k + (im + jm*DIM_X)*9] = f[DIM_X*DIM_Y*9 + k + (id.x + id.y * DIM_X)*9];
        // int im = (int)id.x + (int)cx[k]; 
        // int jm = (int)id.y + (int)cy[k];
        // if((jm!=(int)DIM_Y&&jm!=-1) && (im!=(int)DIM_X&&im!=-1))
        // {
        //     f[k + (im + jm*DIM_X)*9] = f[DIM_X*DIM_Y*9 + k + (id.x + id.y * DIM_X)*9];
        // }
    }
}
[numthreads(64, 1, 1)]
void Boundaries(uint3 id : SV_DispatchThreadID)
{
    float localRho;
    if(id.x < DIM_Y)
    {
        f[1 + (0 + id.x*DIM_X)*9] = f[3 + (0 + id.x*DIM_X)*9];
        f[5 + (0 + id.x*DIM_X)*9] = f[7 + (0 + id.x*DIM_X)*9];
        f[8 + (0 + id.x*DIM_X)*9] = f[6 + (0 + id.x*DIM_X)*9];
        f[3 + (DIM_Y-1 + id.x*DIM_X)*9] = f[1 + (DIM_Y-1 + id.x*DIM_X)*9]; 
        f[7 + (DIM_Y-1 + id.x*DIM_X)*9] = f[5 + (DIM_Y-1 + id.x*DIM_X)*9]; 
        f[6 + (DIM_Y-1 + id.x*DIM_X)*9] = f[8 + (DIM_Y-1 + id.x*DIM_X)*9]; 
    }
    
    if(id.x < DIM_X)
    {
        localRho = 
        f[0+ (id.x + (DIM_Y-1)*DIM_X)*9] + f[1+ (id.x + (DIM_Y-1)*DIM_X)*9] + f[3+ (id.x + (DIM_Y-1)*DIM_X)*9] 
        +2.0 * (f[2+ (id.x + (DIM_Y-1)*DIM_X)*9] + f[6+ (id.x + (DIM_Y-1)*DIM_X)*9]  +f[5+ (id.x + (DIM_Y-1)*DIM_X)*9]);
        
        f[4+ (id.x + (DIM_Y-1)*DIM_X)*9] = f[2+ (id.x + (DIM_Y-1)*DIM_X)*9];
        f[7+ (id.x + (DIM_Y-1)*DIM_X)*9] = f[5+ (id.x + (DIM_Y-1)*DIM_X)*9]-localRho*u0/6.0;
        f[8+ (id.x + (DIM_Y-1)*DIM_X)*9] = f[6+ (id.x + (DIM_Y-1)*DIM_X)*9]+localRho*u0/6.0;

        f[2+ (id.x + 0*DIM_X)*9] = f[4+ (id.x + 0*DIM_X)*9]; 
        f[5+ (id.x + 0*DIM_X)*9] = f[7+ (id.x + 0*DIM_X)*9];  
        f[6+ (id.x + 0*DIM_X)*9] = f[8+ (id.x + 0*DIM_X)*9];  
    }
}

[numthreads(8, 8, 1)]
void PlotSpeed(uint3 id : SV_DispatchThreadID)
{
    float speed = sqrt(uv[(id.x + id.y * DIM_X)*2 + 0]*uv[(id.x + id.y * DIM_X)*2 + 0] + uv[(id.x + id.y * DIM_X)*2 + 1]*uv[(id.x + id.y * DIM_X)*2 + 1]);
    renderTexture[id.xy] = ColorMap(speed-minSpeed,maxSpeed-minSpeed);
}
int PeriodicX(int x)
{
    return (x + DIM_X)%DIM_X;
}
int PeriodicY(int y)
{
    return (y + DIM_Y)%DIM_Y;
}
float2 PeriodicPos(float2 pos)
{
    if(pos.x < 0) pos.x += (float)DIM_X;
    if(pos.x > (float)DIM_X) pos.x -= (float)DIM_X;
    if(pos.y < 0) pos.y += (float)DIM_Y;
    if(pos.y > (float)DIM_Y) pos.y -= (float)DIM_Y;
    return float2(pos.x,pos.y);
}
[numthreads(8, 8, 1)]
void PlotParticle(uint3 id : SV_DispatchThreadID)
{
    int i,j;
    particleRenderTexture[id.xy] = float4(0,0,0,0);
    float2 offsets[] = {
        float2(0,0),
        float2(DIM_X,0),
        float2(-(float)DIM_X,0),
        float2(0,DIM_Y),
        float2(0,-(float)DIM_Y),
    };
    for(i = 0; i < particleCount; i++)
    {
        for(j = 0; j < 5; j++)
        {
            float2 distVec = roundParticleSmallDataBuffer[i].pos + offsets[j] - float2( float((DIM_X-1)*id.x)/float((ParticleDIM_X-1)),float((DIM_Y-1)*id.y)/float((ParticleDIM_Y-1)));
            // float2 distVec = float2(DIM_X/2,DIM_Y/2)- float2(id.x,id.y);
            float norm = distVec.x * distVec.x + distVec.y * distVec.y;
            if(norm < particleRadius*particleRadius){ 
                particleRenderTexture[id.xy] = float4(1,1,1,1);
                float zInCircle = cos(roundParticleSmallDataBuffer[i].theta) * distVec.y - sin(roundParticleSmallDataBuffer[i].theta) * distVec.x;
                float dotFactor = cos(roundParticleSmallDataBuffer[i].theta) * distVec.x + sin(roundParticleSmallDataBuffer[i].theta) * distVec.y;
                if(dotFactor < 0 && abs(zInCircle) < 0.1 * particleRadius)
                {
                    particleRenderTexture[id.xy] = float4(0,0,0,1);
                }
            }
        }
    }
}
[numthreads(8, 8, 1)]
void PlotParticleOnlyEdge(uint3 id : SV_DispatchThreadID)
{
    int i,j;
    particleRenderTexture[id.xy] = float4(0,0,0,0);
    float2 offsets[] = {
        float2(0,0),
        float2(DIM_X,0),
        float2(-(float)DIM_X,0),
        float2(0,DIM_Y),
        float2(0,-(float)DIM_Y),
    };
    for(i = 0; i < particleCount; i++)
    {
        for(j = 0; j < 5; j++)
        {
            float2 distVec = roundParticleSmallDataBuffer[i].pos + offsets[j] - float2( float((DIM_X-1)*id.x)/float((ParticleDIM_X-1)),float((DIM_Y-1)*id.y)/float((ParticleDIM_Y-1)));
            // float2 distVec = float2(DIM_X/2,DIM_Y/2)- float2(id.x,id.y);
            float norm = distVec.x * distVec.x + distVec.y * distVec.y;
            float r2 = roundParticleSmallDataBuffer[i].radius*roundParticleSmallDataBuffer[i].radius;
            if(roundParticleSmallDataBuffer[i].notActive)
            {
                if( norm < r2){ 
                    particleRenderTexture[id.xy] = float4(1,1,1,1);
                }
            }
            else
            {
                if( norm < r2 && norm > r2*0.9){ 
                    particleRenderTexture[id.xy] = float4(1,1,1,1);
                    // float zInCircle = cos(roundParticleSmallDataBuffer[i].theta) * distVec.y - sin(roundParticleSmallDataBuffer[i].theta) * distVec.x;
                    // float dotFactor = cos(roundParticleSmallDataBuffer[i].theta) * distVec.x + sin(roundParticleSmallDataBuffer[i].theta) * distVec.y;
                    // if(dotFactor < 0 && abs(zInCircle) < 0.1 * particleRadius)
                    // {
                    //     particleRenderTexture[id.xy] = float4(0,0,0,1);
                    // }
                }
            }
            
        }
    }
}

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

[numthreads(64,1,1)]
void InitRoundParticles(uint3 id : SV_DispatchThreadID)
{
    float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
    int i;
    float angle;
    roundParticleSmallDataBuffer[id.x].density = particleDensity;
    roundParticleSmallDataBuffer[id.x].radius = particleRadius;
    roundParticleSmallDataBuffer[id.x].volume = pi * particleRadius * particleRadius;
    roundParticleSmallDataBuffer[id.x].mass = pi * particleRadius * particleRadius * particleDensity;
    roundParticleSmallDataBuffer[id.x].momentOfInertia = (pi * particleRadius * particleRadius * particleRadius * particleRadius * particleDensity)/2.0;
    roundParticleSmallDataBuffer[id.x].pos = particleInitPos[id.x];
    roundParticleSmallDataBuffer[id.x].vel = float2(0,0);
    roundParticleSmallDataBuffer[id.x].prevVel1 = float2(0,0);
    roundParticleSmallDataBuffer[id.x].prevVel2 = float2(0,0);
    roundParticleSmallDataBuffer[id.x].omega = 0;
    roundParticleSmallDataBuffer[id.x].theta = Random(id.x) * 2.0 * pi;
    roundParticleSmallDataBuffer[id.x].prevOmega1 = 0;
    roundParticleSmallDataBuffer[id.x].prevOmega2 = 0;
    roundParticleSmallDataBuffer[id.x].perimeterPointCount = particlePerimeterCount;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions = float2(0,0);
    roundParticleSmallDataBuffer[id.x].forceFromFluid = float2(0,0);
    roundParticleSmallDataBuffer[id.x].torque = 0;

    for(i = 0; i < roundParticleSmallDataBuffer[id.x].perimeterPointCount; i++) 
    {
        angle =  2.0*pi*float(i)/float(particlePerimeterCount) + roundParticleSmallDataBuffer[id.x].theta;

        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius * cos(angle);
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius * sin(angle);
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].vel.x - roundParticleSmallDataBuffer[id.x].omega*(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y - roundParticleSmallDataBuffer[id.x].pos.y);
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].vel.y + roundParticleSmallDataBuffer[id.x].omega*(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x - roundParticleSmallDataBuffer[id.x].pos.x);
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + i] = float2(0,0);
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + i] = float2(0,0);
    } 
}
[numthreads(64,1,1)]
void InitRoundParticlesAtCenter(uint3 id : SV_DispatchThreadID)
{
    float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
    int i;
    float angle;
    float r = particleRadius;
    float d = particleDensity;
    if(id.x != 0)
    {
        r = colloidRadius;
        d = colloidDensity;
    }
    roundParticleSmallDataBuffer[id.x].density = d;
    roundParticleSmallDataBuffer[id.x].radius = r;
    roundParticleSmallDataBuffer[id.x].volume = pi * r * r;
    roundParticleSmallDataBuffer[id.x].mass = pi * r * r * d;
    roundParticleSmallDataBuffer[id.x].momentOfInertia = (pi * r * r * r * r * d)/2.0;
    roundParticleSmallDataBuffer[id.x].pos = float2(DIM_X/2,DIM_Y/2);
    if(id.x != 0)
    {
        roundParticleSmallDataBuffer[id.x].pos += float2(Random(id.x),Random(id.x+1)) * particleRadius/2;
    }
    roundParticleSmallDataBuffer[id.x].vel = float2(0,0);
    roundParticleSmallDataBuffer[id.x].prevVel1 = float2(0,0);
    roundParticleSmallDataBuffer[id.x].prevVel2 = float2(0,0);
    roundParticleSmallDataBuffer[id.x].omega = 0;
    roundParticleSmallDataBuffer[id.x].theta = pi/2.0;
    roundParticleSmallDataBuffer[id.x].prevOmega1 = 0;
    roundParticleSmallDataBuffer[id.x].prevOmega2 = 0;
    roundParticleSmallDataBuffer[id.x].perimeterPointCount = particlePerimeterCount;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions = float2(0,0);
    roundParticleSmallDataBuffer[id.x].forceFromFluid = float2(0,0);
    roundParticleSmallDataBuffer[id.x].torque = 0;
    if(id.x != 0)roundParticleSmallDataBuffer[id.x].notActive = true;

    for(i = 0; i < roundParticleSmallDataBuffer[id.x].perimeterPointCount; i++) 
    {
        angle =  2.0*pi*float(i)/float(particlePerimeterCount) + roundParticleSmallDataBuffer[id.x].theta;

        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius * cos(angle);
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius * sin(angle);
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].vel.x - roundParticleSmallDataBuffer[id.x].omega*(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y - roundParticleSmallDataBuffer[id.x].pos.y);
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].vel.y + roundParticleSmallDataBuffer[id.x].omega*(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x - roundParticleSmallDataBuffer[id.x].pos.x);
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + i] = float2(0,0);
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + i] = float2(0,0);
    } 
}

float Magnitude(float2 vec)
{
    return sqrt(SqrMagnitude(vec));
}

float2 NormalizeVec(float2 vec)
{
    return vec/Magnitude(vec);
}

[numthreads(64,1,1)]
void DrawParticleBoundary (uint3 id : SV_DispatchThreadID)
{
    float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
    int i,m,j;
    float tmp1,tmp2,tmp3;
    drawParticleSmallDataBuffer[id.x].forceFromCollisions.x = 0;
    drawParticleSmallDataBuffer[id.x].forceFromCollisions.y = 0;

    float2 offsets[] = {
        float2(0,0),
        float2(DIM_X,0),
        float2(-(float)DIM_X,0),
        float2(0,DIM_Y),
        float2(0,-(float)DIM_Y),
    };

    drawParticleSmallDataBuffer[id.x].forceFromFluid.x = 0;
    drawParticleSmallDataBuffer[id.x].forceFromFluid.y = 0;
    drawParticleSmallDataBuffer[id.x].torque = 0;
    int ppc = drawParticleSmallDataBuffer[id.x].perimeterPointCount;
    for(m = 0; m < ppc; m++) 
    {
        drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].x = 0;
        drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].y = 0;
        // 固体表面の速度を計算
        for(i = (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].x - 3; i < (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].x + 3; i++)
        {
            for(j = (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].y - 3; j < (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].y + 3; j++)
            {
                tmp1 = abs(drawParticlePerimeterPosBuffer[id.x*ppc + m].x - (float)i);
                tmp2 = abs(drawParticlePerimeterPosBuffer[id.x*ppc + m].y - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                }
                else 
                {
                    tmp3 = 0.0;
                }
                // if((j<(int)DIM_Y&&j>=0) && (i<(int)DIM_X&&i>=0))
                // {
                //     drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].x += uv[(i + j * DIM_X)*2 + 0]*tmp3;
                //     drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].y += uv[(i + j * DIM_X)*2 + 1]*tmp3;
                // }
                int x = PeriodicX(i);
                int y = PeriodicX(j);
                drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].x += uv[(x + y * DIM_X)*2 + 0]*tmp3;
                drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].y += uv[(x + y * DIM_X)*2 + 1]*tmp3;
            } 
        }
        float boundaryPointTheta = m * 2 * pi / drawParticleSmallDataBuffer[id.x].perimeterPointCount;
        float2 tangentialDirection = NormalizeVec(drawParticlePerimeterPosBuffer[id.x*ppc + (m+1)%(uint)ppc]-drawParticlePerimeterPosBuffer[id.x*ppc + m]);
        float sn = sin(boundaryPointTheta);
        float cs = cos(boundaryPointTheta);
        float surfaceVelocityNorm = squirmerSpeedConstant * ( sn + 2 * squirmerBeta * sn * cs );
        // float2 surfaceVelocity = float2(-sin(boundaryPointTheta + drawParticleSmallDataBuffer[id.x].theta) * surfaceVelocityNorm , cos(boundaryPointTheta + drawParticleSmallDataBuffer[id.x].theta) * surfaceVelocityNorm);
        float2 surfaceVelocity = tangentialDirection * surfaceVelocityNorm;
        drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].x += surfaceVelocity.x;
        drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].y += surfaceVelocity.y;
        drawParticleForceOnPerimeterBuffer[id.x*ppc + m].x = drawParticlePerimeterVelBuffer[id.x*ppc + m].x - drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].x;
        drawParticleForceOnPerimeterBuffer[id.x*ppc + m].y = drawParticlePerimeterVelBuffer[id.x*ppc + m].y - drawParticlePerimeterFluidVelBuffer[id.x*ppc + m].y;

        // 固体が外部に与える力を計算
        for(i = (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].x - 3; i < (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].x + 3; i++)
        {
            for(j = (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].y - 3; j < (int)drawParticlePerimeterPosBuffer[id.x*ppc + m].y + 3; j++)
            {
                tmp1 = abs(drawParticlePerimeterPosBuffer[id.x*ppc + m].x - (float)i);
                tmp2 = abs(drawParticlePerimeterPosBuffer[id.x*ppc + m].y - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                int x = PeriodicX(i);
                int y = PeriodicX(j);
                force[0 + (x + y * DIM_X)*2] += drawParticleForceOnPerimeterBuffer[id.x*ppc + m].x * tmp3 * particlePointLatticeSpacing;
                force[1 + (x + y * DIM_X)*2] += drawParticleForceOnPerimeterBuffer[id.x*ppc + m].y * tmp3 * particlePointLatticeSpacing;
            } 
        }
        drawParticleSmallDataBuffer[id.x].forceFromFluid.x += drawParticleForceOnPerimeterBuffer[id.x*ppc + m].x;
        drawParticleSmallDataBuffer[id.x].forceFromFluid.y += drawParticleForceOnPerimeterBuffer[id.x*ppc + m].y;
        float xdiff = drawParticlePerimeterPosBuffer[id.x*ppc + m].x - drawParticleSmallDataBuffer[id.x].pos.x;
        float ydiff = drawParticlePerimeterPosBuffer[id.x*ppc + m].y - drawParticleSmallDataBuffer[id.x].pos.y;
        for(i = 0;i < 5;i++)
        {
            float dx = drawParticlePerimeterPosBuffer[id.x*ppc + m].x - drawParticleSmallDataBuffer[id.x].pos.x + offsets[i].x;
            float dy = drawParticlePerimeterPosBuffer[id.x*ppc + m].y - drawParticleSmallDataBuffer[id.x].pos.y + offsets[i].y;
            if(abs(dx) < abs(xdiff))
            {
                xdiff = dx;
            }
            if(abs(dy) < abs(ydiff))
            {
                ydiff = dy;
            }
        }
        drawParticleSmallDataBuffer[id.x].torque += drawParticleForceOnPerimeterBuffer[id.x*ppc + m].y * xdiff 
                                - drawParticleForceOnPerimeterBuffer[id.x*ppc + m].x * ydiff;
    } 

    drawParticleSmallDataBuffer[id.x].forceFromFluid.x *= -particlePointLatticeSpacing;  
    drawParticleSmallDataBuffer[id.x].forceFromFluid.y *= -particlePointLatticeSpacing;  
    drawParticleSmallDataBuffer[id.x].torque *= -particlePointLatticeSpacing;  

    drawParticleSmallDataBuffer[id.x].vel = (1.0 + 1.0/drawParticleSmallDataBuffer[id.x].density) * drawParticleSmallDataBuffer[id.x].prevVel1
                            - 1.0/drawParticleSmallDataBuffer[id.x].density * drawParticleSmallDataBuffer[id.x].prevVel2
                            + (drawParticleSmallDataBuffer[id.x].forceFromFluid + drawParticleSmallDataBuffer[id.x].forceFromCollisions)/drawParticleSmallDataBuffer[id.x].mass;
                            
    drawParticleSmallDataBuffer[id.x].pos += (drawParticleSmallDataBuffer[id.x].vel + drawParticleSmallDataBuffer[id.x].prevVel1)/2.0;
    drawParticleSmallDataBuffer[id.x].pos = PeriodicPos(drawParticleSmallDataBuffer[id.x].pos);
    drawParticleSmallDataBuffer[id.x].prevVel2 = drawParticleSmallDataBuffer[id.x].prevVel1;
    drawParticleSmallDataBuffer[id.x].prevVel1 = drawParticleSmallDataBuffer[id.x].vel;

    drawParticleSmallDataBuffer[id.x].omega = (1.0 + 1.0/drawParticleSmallDataBuffer[id.x].density) * drawParticleSmallDataBuffer[id.x].prevOmega1 
                            - 1.0/drawParticleSmallDataBuffer[id.x].density * drawParticleSmallDataBuffer[id.x].prevOmega2
                            + drawParticleSmallDataBuffer[id.x].torque/drawParticleSmallDataBuffer[id.x].momentOfInertia;
    drawParticleSmallDataBuffer[id.x].theta += (drawParticleSmallDataBuffer[id.x].omega + drawParticleSmallDataBuffer[id.x].prevOmega1)/2.0;
    drawParticleSmallDataBuffer[id.x].prevOmega2 = drawParticleSmallDataBuffer[id.x].prevOmega1;
    drawParticleSmallDataBuffer[id.x].prevOmega1 = drawParticleSmallDataBuffer[id.x].omega;

    drawParticleSmallDataBuffer[id.x].time++;
    for(i = 0; i < drawParticleSmallDataBuffer[id.x].perimeterPointCount; i++) 
    {
        // float spacePhase = 2*pi*(float(wavecount*i)/float(ppc));
        // float timeScale = 2*pi/float(shuuki);
        float spacePhase = 2*pi*(float(wavecount*i)/float(ppc));
        float timeScale = 2*pi/float(shuuki);
        float timePhase = timeScale*float(drawParticleSmallDataBuffer[id.x].time);
        float phase = spacePhase - timePhase;
        float2 relPos = drawParticlePerimeterRelPosBuffer[id.x*ppc + i];
        if(drawParticleMode == 1) relPos = drawParticlePerimeterRelPosBuffer[id.x*ppc + i]*( 1 + wavescale*cos(phase));

        float xdiff = drawParticlePerimeterPosBuffer[id.x*ppc + i].x - drawParticleSmallDataBuffer[id.x].pos.x;
        float ydiff = drawParticlePerimeterPosBuffer[id.x*ppc + i].y - drawParticleSmallDataBuffer[id.x].pos.y;
        for(j = 0;j < 5;j++)
        {
            float dx = drawParticlePerimeterPosBuffer[id.x*ppc + i].x - drawParticleSmallDataBuffer[id.x].pos.x + offsets[j].x;
            float dy = drawParticlePerimeterPosBuffer[id.x*ppc + i].y - drawParticleSmallDataBuffer[id.x].pos.y + offsets[j].y;
            if(abs(dx) < abs(xdiff))
            {
                xdiff = dx;
            }
            if(abs(dy) < abs(ydiff))
            {
                ydiff = dy;
            }
        }
        // float2 periRelPos = RotateVec(drawParticlePerimeterRelPosBuffer[id.x*ppc + i],drawParticleSmallDataBuffer[id.x].theta);
        float2 periRelPos = RotateVec(relPos,drawParticleSmallDataBuffer[id.x].theta);
        // float2 periRelPosNormal = periRelPos/sqrt(periRelPos.x*periRelPos.x + periRelPos.y*periRelPos.y);
        drawParticlePerimeterPosBuffer[id.x*ppc + i] = periRelPos + drawParticleSmallDataBuffer[id.x].pos;
        drawParticlePerimeterVelBuffer[id.x*ppc + i].x = drawParticleSmallDataBuffer[id.x].vel.x - drawParticleSmallDataBuffer[id.x].omega*ydiff;
        drawParticlePerimeterVelBuffer[id.x*ppc + i].y = drawParticleSmallDataBuffer[id.x].vel.y + drawParticleSmallDataBuffer[id.x].omega*xdiff;
        drawParticlePerimeterPosBuffer[id.x*ppc + i] = PeriodicPos(drawParticlePerimeterPosBuffer[id.x*ppc + i]);

        if(drawParticleMode == 1) drawParticlePerimeterVelBuffer[id.x*ppc + i] += periRelPos *wavescale*timeScale*sin(phase);
    } 
} 

[numthreads(64,1,1)]
void ImmersedBoundary (uint3 id : SV_DispatchThreadID)
{
    float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
    int i,m,j;
    float tmp1,tmp2,tmp3;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions.x = 0;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions.y = 0;
    // tmp1 = abs(roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius); 
    // if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
    //     roundParticleSmallDataBuffer[id.x].forceFromCollisions.y = (roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    // }
    // tmp1 = abs(DIM_Y-1-roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius); 
    // if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
    //     roundParticleSmallDataBuffer[id.x].forceFromCollisions.y = -(DIM_Y-1-roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    // }
    // tmp1 = abs(roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius); 
    // if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
    //     roundParticleSmallDataBuffer[id.x].forceFromCollisions.x = (roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    // }
    // tmp1 = abs(DIM_X-1-roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius); 
    // if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
    //     roundParticleSmallDataBuffer[id.x].forceFromCollisions.x = -(DIM_X-1-roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    // }


    float2 offsets[] = {
        float2(0,0),
        float2(DIM_X,0),
        float2(-(float)DIM_X,0),
        float2(0,DIM_Y),
        float2(0,-(float)DIM_Y),
    };
    for (j = 0; j < particleCount; j++)
    {
        if(j==(int)id.x) continue;
        for(i = 0; i < 5; i++)
        {
            float2 distVec = roundParticleSmallDataBuffer[id.x].pos - roundParticleSmallDataBuffer[j].pos + offsets[i];
            tmp1 = sqrt(distVec.x * distVec.x + distVec.y*distVec.y);
            if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
                roundParticleSmallDataBuffer[id.x].forceFromCollisions += (distVec)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
                break;
            }
        }   
        
    }

    roundParticleSmallDataBuffer[id.x].forceFromFluid.x = 0;
    roundParticleSmallDataBuffer[id.x].forceFromFluid.y = 0;
    roundParticleSmallDataBuffer[id.x].torque = 0;
    for(m = 0; m < roundParticleSmallDataBuffer[id.x].perimeterPointCount ; m++) 
    {
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x = 0;
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y = 0;
        // 固体表面の速度を計算
        for(i = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - 3; i < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x + 3; i++)
        {
            for(j = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - 3; j < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y + 3; j++)
            {
                tmp1 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - (float)i);
                tmp2 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                }
                else 
                {
                    tmp3 = 0.0;
                }
                // if((j<(int)DIM_Y&&j>=0) && (i<(int)DIM_X&&i>=0))
                // {
                //     roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x += uv[(i + j * DIM_X)*2 + 0]*tmp3;
                //     roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y += uv[(i + j * DIM_X)*2 + 1]*tmp3;
                // }
                int x = PeriodicX(i);
                int y = PeriodicX(j);
                roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x += uv[(x + y * DIM_X)*2 + 0]*tmp3;
                roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y += uv[(x + y * DIM_X)*2 + 1]*tmp3;
            } 
        }
        float boundaryPointTheta = m * 2 * pi / roundParticleSmallDataBuffer[id.x].perimeterPointCount;
        float sn = sin(boundaryPointTheta);
        float cs = cos(boundaryPointTheta);
        float surfaceVelocityNorm = squirmerSpeedConstant * ( sn + 2 * squirmerBeta * sn * cs );
        float2 surfaceVelocity = float2(-sin(boundaryPointTheta + roundParticleSmallDataBuffer[id.x].theta) * surfaceVelocityNorm , cos(boundaryPointTheta + roundParticleSmallDataBuffer[id.x].theta) * surfaceVelocityNorm);
        if(roundParticleSmallDataBuffer[id.x].notActive) surfaceVelocity = float2(0,0);
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x += surfaceVelocity.x;
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y += surfaceVelocity.y;
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x = roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + m].x - roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x;
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y = roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + m].y - roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y;

        // 固体が外部に与える力を計算
        for(i = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - 3; i < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x + 3; i++)
        {
            for(j = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - 3; j < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y + 3; j++)
            {
                tmp1 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - (float)i);
                tmp2 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                // if((j<(int)DIM_Y&&j>=0) && (i<(int)DIM_X&&i>=0))
                // {
                //     force[0 + (i + j * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                //     force[1 + (i + j * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                //     // force[0 + (i + j * DIM_X)*2] = 10000000;
                //     // force[1 + (i + j * DIM_X)*2] = 10000000;
                // }
                int x = PeriodicX(i);
                int y = PeriodicX(j);
                force[0 + (x + y * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                force[1 + (x + y * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
            } 
        }
        roundParticleSmallDataBuffer[id.x].forceFromFluid.x += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x;
        roundParticleSmallDataBuffer[id.x].forceFromFluid.y += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y;
        float xdiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - roundParticleSmallDataBuffer[id.x].pos.x;
        float ydiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - roundParticleSmallDataBuffer[id.x].pos.y;
        for(i = 0;i < 5;i++)
        {
            float dx = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - roundParticleSmallDataBuffer[id.x].pos.x + offsets[i].x;
            float dy = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - roundParticleSmallDataBuffer[id.x].pos.y + offsets[i].y;
            if(abs(dx) < abs(xdiff))
            {
                xdiff = dx;
            }
            if(abs(dy) < abs(ydiff))
            {
                ydiff = dy;
            }
        }
        roundParticleSmallDataBuffer[id.x].torque += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y * xdiff 
                                - roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x * ydiff;
    } 

    roundParticleSmallDataBuffer[id.x].forceFromFluid.x *= -2*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  
    roundParticleSmallDataBuffer[id.x].forceFromFluid.y *= -2*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  
    roundParticleSmallDataBuffer[id.x].torque *= -2*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  

    roundParticleSmallDataBuffer[id.x].vel = (1.0 + 1.0/roundParticleSmallDataBuffer[id.x].density) * roundParticleSmallDataBuffer[id.x].prevVel1
                            - 1.0/roundParticleSmallDataBuffer[id.x].density * roundParticleSmallDataBuffer[id.x].prevVel2
                            + (roundParticleSmallDataBuffer[id.x].forceFromFluid + roundParticleSmallDataBuffer[id.x].forceFromCollisions)/roundParticleSmallDataBuffer[id.x].mass;
                            
    roundParticleSmallDataBuffer[id.x].pos += (roundParticleSmallDataBuffer[id.x].vel + roundParticleSmallDataBuffer[id.x].prevVel1)/2.0;
    roundParticleSmallDataBuffer[id.x].pos = PeriodicPos(roundParticleSmallDataBuffer[id.x].pos);
    roundParticleSmallDataBuffer[id.x].prevVel2 = roundParticleSmallDataBuffer[id.x].prevVel1;
    roundParticleSmallDataBuffer[id.x].prevVel1 = roundParticleSmallDataBuffer[id.x].vel;

    roundParticleSmallDataBuffer[id.x].omega = (1.0 + 1.0/roundParticleSmallDataBuffer[id.x].density) * roundParticleSmallDataBuffer[id.x].prevOmega1 
                            - 1.0/roundParticleSmallDataBuffer[id.x].density * roundParticleSmallDataBuffer[id.x].prevOmega2
                            + roundParticleSmallDataBuffer[id.x].torque/roundParticleSmallDataBuffer[id.x].momentOfInertia;
    roundParticleSmallDataBuffer[id.x].theta += (roundParticleSmallDataBuffer[id.x].omega + roundParticleSmallDataBuffer[id.x].prevOmega1)/2.0;
    roundParticleSmallDataBuffer[id.x].prevOmega2 = roundParticleSmallDataBuffer[id.x].prevOmega1;
    roundParticleSmallDataBuffer[id.x].prevOmega1 = roundParticleSmallDataBuffer[id.x].omega;

    for(i = 0; i < roundParticleSmallDataBuffer[id.x].perimeterPointCount; i++) 
    {
        float angle =  2.0*pi*float(i)/float(particlePerimeterCount) + roundParticleSmallDataBuffer[id.x].theta;
        float xdiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x - roundParticleSmallDataBuffer[id.x].pos.x;
        float ydiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y - roundParticleSmallDataBuffer[id.x].pos.y;
        for(j = 0;j < 5;j++)
        {
            float dx = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x - roundParticleSmallDataBuffer[id.x].pos.x + offsets[j].x;
            float dy = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y - roundParticleSmallDataBuffer[id.x].pos.y + offsets[j].y;
            if(abs(dx) < abs(xdiff))
            {
                xdiff = dx;
            }
            if(abs(dy) < abs(ydiff))
            {
                ydiff = dy;
            }
        }
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius * cos(angle);
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius * sin(angle);
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].vel.x - roundParticleSmallDataBuffer[id.x].omega*ydiff;
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].vel.y + roundParticleSmallDataBuffer[id.x].omega*xdiff;
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i] = PeriodicPos(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i]);
    } 
} 

[numthreads(64,1,1)]
void ImmersedBoundaryColloids (uint3 id : SV_DispatchThreadID)
{
    float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
    int i,m,j;
    float tmp1,tmp2,tmp3;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions.x = 0;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions.y = 0;

    float2 offsets[] = {
        float2(0,0),
        float2(DIM_X,0),
        float2(-(float)DIM_X,0),
        float2(0,DIM_Y),
        float2(0,-(float)DIM_Y),
    };
    if(roundParticleSmallDataBuffer[id.x].notActive)
    {
        for (j = 0; j < particleCount; j++)
        {
            if(j==(int)id.x) continue;
            if(!roundParticleSmallDataBuffer[id.x].notActive) continue;
            for(i = 0; i < 5; i++)
            {
                float2 distVec = roundParticleSmallDataBuffer[id.x].pos - roundParticleSmallDataBuffer[j].pos + offsets[i];
                tmp1 = sqrt(distVec.x * distVec.x + distVec.y*distVec.y);
                if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
                    roundParticleSmallDataBuffer[id.x].forceFromCollisions += (distVec)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
                    break;
                }
            }   
        }
        float2 distVec = roundParticleSmallDataBuffer[id.x].pos - roundParticleSmallDataBuffer[0].pos;
        tmp1 = sqrt(distVec.x * distVec.x + distVec.y*distVec.y);
        float d = roundParticleSmallDataBuffer[0].radius - (tmp1 + roundParticleSmallDataBuffer[id.x].radius);
        // float d = distToEdge/roundParticleSmallDataBuffer[0].radius;
        if(tmp1 != 0)roundParticleSmallDataBuffer[id.x].forceFromCollisions += -10.0/pow(d,2) * distVec/tmp1;
    }
    

    roundParticleSmallDataBuffer[id.x].forceFromFluid.x = 0;
    roundParticleSmallDataBuffer[id.x].forceFromFluid.y = 0;
    roundParticleSmallDataBuffer[id.x].torque = 0;
    for(m = 0; m < roundParticleSmallDataBuffer[id.x].perimeterPointCount ; m++) 
    {
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x = 0;
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y = 0;
        // 固体表面の速度を計算
        for(i = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - 3; i < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x + 3; i++)
        {
            for(j = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - 3; j < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y + 3; j++)
            {
                tmp1 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - (float)i);
                tmp2 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                }
                else 
                {
                    tmp3 = 0.0;
                }
                // if((j<(int)DIM_Y&&j>=0) && (i<(int)DIM_X&&i>=0))
                // {
                //     roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x += uv[(i + j * DIM_X)*2 + 0]*tmp3;
                //     roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y += uv[(i + j * DIM_X)*2 + 1]*tmp3;
                // }
                int x = PeriodicX(i);
                int y = PeriodicX(j);
                roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x += uv[(x + y * DIM_X)*2 + 0]*tmp3;
                roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y += uv[(x + y * DIM_X)*2 + 1]*tmp3;
            } 
        }
        float boundaryPointTheta = m * 2 * pi / roundParticleSmallDataBuffer[id.x].perimeterPointCount;
        float sn = sin(boundaryPointTheta);
        float cs = cos(boundaryPointTheta);
        float surfaceVelocityNorm = squirmerSpeedConstant * ( sn + 2 * squirmerBeta * sn * cs );
        float2 surfaceVelocity = float2(-sin(boundaryPointTheta + roundParticleSmallDataBuffer[id.x].theta) * surfaceVelocityNorm , cos(boundaryPointTheta + roundParticleSmallDataBuffer[id.x].theta) * surfaceVelocityNorm);
        if(roundParticleSmallDataBuffer[id.x].notActive) surfaceVelocity = float2(0,0);
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x += surfaceVelocity.x;
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y += surfaceVelocity.y;
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x = roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + m].x - roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].x;
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y = roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + m].y - roundParticleRoundParticlePerimeterFluidVelBuffer[id.x*particlePerimeterCount + m].y;

        // 固体が外部に与える力を計算
        for(i = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - 3; i < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x + 3; i++)
        {
            for(j = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - 3; j < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y + 3; j++)
            {
                tmp1 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - (float)i);
                tmp2 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                // if((j<(int)DIM_Y&&j>=0) && (i<(int)DIM_X&&i>=0))
                // {
                //     force[0 + (i + j * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                //     force[1 + (i + j * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                //     // force[0 + (i + j * DIM_X)*2] = 10000000;
                //     // force[1 + (i + j * DIM_X)*2] = 10000000;
                // }
                int x = PeriodicX(i);
                int y = PeriodicX(j);
                force[0 + (x + y * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                force[1 + (x + y * DIM_X)*2] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
            } 
        }
        roundParticleSmallDataBuffer[id.x].forceFromFluid.x += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x;
        roundParticleSmallDataBuffer[id.x].forceFromFluid.y += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y;
        float xdiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - roundParticleSmallDataBuffer[id.x].pos.x;
        float ydiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - roundParticleSmallDataBuffer[id.x].pos.y;
        for(i = 0;i < 5;i++)
        {
            float dx = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].x - roundParticleSmallDataBuffer[id.x].pos.x + offsets[i].x;
            float dy = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + m].y - roundParticleSmallDataBuffer[id.x].pos.y + offsets[i].y;
            if(abs(dx) < abs(xdiff))
            {
                xdiff = dx;
            }
            if(abs(dy) < abs(ydiff))
            {
                ydiff = dy;
            }
        }
        roundParticleSmallDataBuffer[id.x].torque += roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].y * xdiff 
                                - roundParticleRoundParticleForceOnPerimeterBuffer[id.x*particlePerimeterCount + m].x * ydiff;
    } 

    roundParticleSmallDataBuffer[id.x].forceFromFluid.x *= -2*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  
    roundParticleSmallDataBuffer[id.x].forceFromFluid.y *= -2*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  
    roundParticleSmallDataBuffer[id.x].torque *= -2*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  

    roundParticleSmallDataBuffer[id.x].vel = (1.0 + 1.0/roundParticleSmallDataBuffer[id.x].density) * roundParticleSmallDataBuffer[id.x].prevVel1
                            - 1.0/roundParticleSmallDataBuffer[id.x].density * roundParticleSmallDataBuffer[id.x].prevVel2
                            + (roundParticleSmallDataBuffer[id.x].forceFromFluid + roundParticleSmallDataBuffer[id.x].forceFromCollisions)/roundParticleSmallDataBuffer[id.x].mass;
                            
    roundParticleSmallDataBuffer[id.x].pos += (roundParticleSmallDataBuffer[id.x].vel + roundParticleSmallDataBuffer[id.x].prevVel1)/2.0;
    roundParticleSmallDataBuffer[id.x].pos = PeriodicPos(roundParticleSmallDataBuffer[id.x].pos);
    roundParticleSmallDataBuffer[id.x].prevVel2 = roundParticleSmallDataBuffer[id.x].prevVel1;
    roundParticleSmallDataBuffer[id.x].prevVel1 = roundParticleSmallDataBuffer[id.x].vel;

    roundParticleSmallDataBuffer[id.x].omega = (1.0 + 1.0/roundParticleSmallDataBuffer[id.x].density) * roundParticleSmallDataBuffer[id.x].prevOmega1 
                            - 1.0/roundParticleSmallDataBuffer[id.x].density * roundParticleSmallDataBuffer[id.x].prevOmega2
                            + roundParticleSmallDataBuffer[id.x].torque/roundParticleSmallDataBuffer[id.x].momentOfInertia;
    roundParticleSmallDataBuffer[id.x].theta += (roundParticleSmallDataBuffer[id.x].omega + roundParticleSmallDataBuffer[id.x].prevOmega1)/2.0;
    roundParticleSmallDataBuffer[id.x].prevOmega2 = roundParticleSmallDataBuffer[id.x].prevOmega1;
    roundParticleSmallDataBuffer[id.x].prevOmega1 = roundParticleSmallDataBuffer[id.x].omega;

    for(i = 0; i < roundParticleSmallDataBuffer[id.x].perimeterPointCount; i++) 
    {
        float angle =  2.0*pi*float(i)/float(particlePerimeterCount) + roundParticleSmallDataBuffer[id.x].theta;
        float xdiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x - roundParticleSmallDataBuffer[id.x].pos.x;
        float ydiff = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y - roundParticleSmallDataBuffer[id.x].pos.y;
        for(j = 0;j < 5;j++)
        {
            float dx = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x - roundParticleSmallDataBuffer[id.x].pos.x + offsets[j].x;
            float dy = roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y - roundParticleSmallDataBuffer[id.x].pos.y + offsets[j].y;
            if(abs(dx) < abs(xdiff))
            {
                xdiff = dx;
            }
            if(abs(dy) < abs(ydiff))
            {
                ydiff = dy;
            }
        }
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].pos.x + roundParticleSmallDataBuffer[id.x].radius * cos(angle);
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].pos.y + roundParticleSmallDataBuffer[id.x].radius * sin(angle);
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].x = roundParticleSmallDataBuffer[id.x].vel.x - roundParticleSmallDataBuffer[id.x].omega*ydiff;
        roundParticleRoundParticlePerimeterVelBuffer[id.x*particlePerimeterCount + i].y = roundParticleSmallDataBuffer[id.x].vel.y + roundParticleSmallDataBuffer[id.x].omega*xdiff;
        roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i] = PeriodicPos(roundParticleRoundParticlePerimeterPosBuffer[id.x*particlePerimeterCount + i]);
    } 
} 

